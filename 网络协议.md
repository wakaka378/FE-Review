## 网络协议、安全相关

### TCP、UDP协议

`TCP`和`UDP`都是在传输层定义的两种传输协议。基于`UDP`协议传输不能保证数据准确无误的送达，但`UDP`不仅可以支持一对一的传输方式，还可以支持一对一、一对多等形式。也不需要像`TCP`一样建立连接，所以传输速度快。

`TCP`的目的是提供可靠的数据，并且需要在传输前建立连接（三次握手）。只支持一对一进行传输。



**区别：**

- `TCP`协议可靠，`UDP`协议不可靠
- `TCP`面向连接，`UDP`采用无连接
- `TCP`可以保证数据顺序，`UDP`不能
- `TCP`一对一传输，`UDP`可以一对多、多对一等形式





### HTTP和HTTPS区别

- `HTTP`是明文传输，不安全。`HTTPS`基于`SSL`进行加密传输，比较安全。
- `HTTPS`需要`CA`证书，`HTTP`不需要。
- `HTTP`端口为`80`，`HTTPS`端口为`443`





### HTTP状态码

- 1XX: 请求正在处理
- 2XX：正常状态码
  - 200 ：请求处理成功
  - 201 ： 请求成功并且服务器创建了新资源
  - 202 ：服务器已经接收请求，但尚未处理
- 3XXX：重定向状态
  - 301 ：请求重定向
  - 302:  临时重定向
  - 303:  临时重定向，使用get请求新的url
  - 304：浏览器缓存相关
- 4XX：错误状态码
  - 400: 服务器无法理解请求格式，需要修改请求内容后再次发起请求
  - 401: 请求未授权
  - 403: 禁止访问
  - 404: 服务器上无法找到请求资源
- 5XX：服务器错误
  - 500: 服务端错误
  - 503: 服务器暂时无法处理请求



### HTTP三次握手、四次挥手

#### 三次握手

三次握手是在建立`TCP`连接时，客户端和服务端总共发送三个包。进行三次握手的主要目的就是为了确认双方的接受能力和发送能力都是正常的，为后面传输可靠数据做准备。

**报文：**

- 序号：表示发送的数据字节流，确保TCP传输有序，对每个字节编号
- 确认序号：发送方期待接收的下一序列号，接收成功后的数据字节序列号加 1。只有`ACK=1`时才有效。
- `ACK`：确认序号的标志，`ACK=1`表示确认号有效，`ACK=0`表示报文不含确认序号信息
- `SYN`：连接请求序号标志，用于建立连接，`SYN=1`表示请求连接
- `FIN`：结束标志，用于释放连接，`FIN=1`表示关闭本方数据流



**三次握手：**

1. 第一次握手：客户端给服务端发一个 `SYN `报文，并指明客户端的初始化序列号` ISN`，此时客户端处于 `SYN_SEND` 状态。
2. 务器收到客户端的` SYN` 报文之后，会以自己的` SYN `报文作为应答，并且也是指定了自己的初始化序列号` ISN`。同时会把客户端的 `ISN + 1 `作为`ACK`的值，表示自己已经收到了客户端的` SYN`，此时服务器处于 `SYN_REVD `的状态。
3. 客户端收到` SYN `报文之后，会发送一个 `ACK `报文，当然，也是一样把服务器的 `ISN + 1 `作为 `ACK `的值，表示已经收到了服务端的 `SYN `报文，此时客户端处于` ESTABLISHED` 状态。服务器收到 `ACK `报文之后，也处于 `ESTABLISHED 状`态，此时，双方已建立起了连接。



#### 四次挥手

1. 客户端会发送一个` FIN `报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1 `状态。
2. 服务端收到 `FIN` 之后，会发送 `ACK` 报文，且把客户端的序列号值 +1 作为 `ACK `报文的序列号值，表明已经收到客户端的报文了，此时服务端处于` CLOSE_WAIT` 状态。
3. 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 `FIN `报文，且指定一个序列号。此时服务端处于 `LAST_ACK `的状态。
4. 客户端收到` FIN` 之后，一样发送一个` ACK `报文作为应答，且把服务端的序列号值 +1 作为自己 `ACK `报文的序列号值，此时客户端处于 `TIME_WAIT `状态。需要过一阵子以确保服务端收到自己的 `ACK` 报文之后才会进入 `CLOSED `状态，服务端收到 `ACK `报文之后，就处于关闭连接了，处于 `CLOSED` 状态。



#### 为什么需要四次挥手

因为当服务端收到客户端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。其中`ACK`报文是用来应答的，`SYN`报文是用来同步的。但是关闭连接时，当服务端收到`FIN`报文时，很可能并不会立即关闭`SOCKET`，所以只能先回复一个`ACK`报文，告诉客户端，“你发的`FIN`报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送`FIN`报文，因此不能一起发送。故需要四次挥手。





### HTTP缓存

#### 强缓存

使用强制缓存策略，如果缓存资源有效，就直接使用缓存资源，不需要向服务器发送请求。强制缓存通过两种方式来设置，在`request headers`中的`Expires`属性和`Cache-Contorl`属性。

`Expires`属性，指定资源的过期时间。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。

`Cache-Control`属性：

- `private`： 仅浏览器可以缓存
- `public`：浏览器和代理服务器都可以缓存
- `max-age=xxx` 过期时间，单位为秒
- `no-cache` 不进行强缓存，但会有协商缓存
- `no-store `不强缓存，也不协商缓存



如果`request header`中，`Cache- Control`的值中有`max-age=xxx`，这个时候走强缓存。如果值为`no-cache`，表明没有命中，走协商缓存。如值为`no-store`，不使用缓存。



#### 协商缓存

如果没有命中强制缓存，在设置协商缓存情况下，先向服务器发送一个请求，如果资源没有发生修改，则返回一个`304`的状态，让浏览器使用本地的缓存副本。如果资源发生修改，则返回修改后的资源。在`request headers`中的`Etag`属性和`Last-Modified`属性，来进行设置。其中，`ETage`优先于`Last-Modified`。



命中协商缓存条件：

- `Cache-Control: no-cache`
- `max-age`时间过期



**Last-Modified（文件的修改时间）：**

服务器在响应头中添加`Last-Modified`属性，来指出资源最后一次修改时间。当浏览器发起请求时，会在`request headers`中添加一个`If-None-Match`属性，值为上一次请求的资源返回的`Last-Modified`值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。如果资源没有修改，请求返回304状态，客户端使用本地缓存。如果资源有修改，则返回修改的资源。

这种方式有一个缺点，`Last-Modified`标记的时间只能精确到秒。



**ETag（文件改动）：**

同样在服务器返回资源的时候，在头信息中添加`ETag`属性，这个属性是资源的唯一标识符。当资源改变时，这个值也会改变。在一下次请求资源时，会在`request headers`中添加一个`If-None-Match`属性，值为上一次请求的资源返回的`ETag`值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比`Last-Modified`更加准确。



#### 区别

- 强缓存优先级高于协商缓存
- 强缓存不需要发请求，协商缓存需要。
- 强缓存返回的状态码为`200`，协商缓存返回`304`
- ctrl+F5强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。



### POST和GET的区别

- 传递的参数不同，`POST`传递的参数在`request body`中，`GET`传递的参数在`url`后拼接
- `POST`相对`GET`请求安全
- `GET`请求长度有限制，`POST`没有
- `GET`请求会被浏览器主动缓存，`POST`不会，要手动设置
- `GET`请求一般用于查询，`POST`一般用于提交某种信息进行某些修改操作 



### XSS、csrf攻击

#### XSS（跨站脚本攻击）

`Xss(cross-site scripting)` 是一种代码注入攻击，攻击者往` Web `页面里插入恶意 `html` 标签或者 `javascript `代码。在骗取用户点击后获取用户，获取用户信息。



**避免方式：**

- `url`参数通过`encodeURIComponent`方法进行转义
- 尽量不使用`InnerHtml`插入`HTML`内容
- 对用户输入的地方和变量都需要仔细检查长度和对 ”<”,”>”,”;”,”’” 等字符做过滤



#### CSRF（跨站请求伪造）

`CSRF`（`Cross-site request forgery`）攻击者盗用你的身份信息，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

**避免方式：**

- 添加验证码验证
- 使用`token`
  - 服务端给用户生成一个`token`，加密后传递给用户
  - 用户在提交请求时，需要携带这个`token`
  - 服务端验证`token`是否正确





### 前端工程化

### webpack的loader和plugin的区别

#### loader

loader是导出一个函数的javascript模块，webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。如babel-loader、Css-loader、image-loader、url-loader、Saas-loader...



#### plugin

Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。如html-webpack-plugin、mini-css-extract-plugin、uglifyjs-webpack-plugin


